                                    CRYPTLINK Encrypted Server Link Protocol
                                    ========================================
  (Loosely based on draft by A1kmm)
  (Rewritten by David-T, einride, and jdc)

0.1 - Conventions of this document
----------------------------------

	* "MUST" means that a server is not compliant unless it does this.
	* "MUST NOT" means a server is not compliant if it does this.
	* "SHOULD" means that a server is at most conditionally compliant
	  if it does not do this.
	* "SHOULD NOT" means that a server is at most conditionally
	  compliant if it does this.
	* "MAY" means that a server may choose whether or not to do this.


1.1 - Goal of this protocol
---------------------------

	To reduce the risk of attacks relating to password sniffing,
	replay attacks, or connection hijacking, in turn permitting
	unauthorised access to server privileges.

1.2 - Background of this protocol
---------------------------------

	This protocol is based on the IRC protocol as described in RFC1459,
	and extensions implemented on EFnet as described in other documents
	available in this directory (doc/), and on the WWW.

	Any encrypted strings which are transmitted in IRC commands in
	accordance with this document shall be base64 encoded, with the
	most significant bits of the most significant byte transmitted
	first, followed by bits/bytes of decreasing significance.  However,
	the encrypted link itself will be 8-bit, without no encoding.


2.1 - Configuration changes
---------------------------

	Every server which supports encrypted links has a 2048-bit RSA
	private key stored in a configuration file.  Care must be taken
	to ensure this file is accessible only to the ircd user.  For
	every link to another server that supports encrypted links, the
	public component of that server's RSA key is stored instead of the
	traditional password or password hash.

	A server which is configured to make an encrypted link to another
	MUST NOT fall back on any other authentication scheme, regardless
	of what the remote server sends or does.


3.1 - Changes to the CAPAB command
----------------------------------

	The first command sent by a server over an encrypted link MUST
	be a CAPAB command.  The CAPAB command MUST include the
	ENC capability.  The syntax would be as follows:

		CAPAB :<other supported capabilities> ENC:cipher/keylen

	Where "cipher" is the encryption cipher chosen to be used
	bidirectionally, and "keylen" is the key lengths required by
	"cipher."

	The ciphers which are available as of this document are listed
	in doc/README.openssl.

	An example CAPAB could be the following:

		CAPAB :QS EX CHW IE EOB KLN HOPS HUB AOPS ZIP ENC:BF/256

	The maximum allowable key length permitted for the encryption
	cipher is 512 bits, as only 64 bytes of random data for the
	key is available.

	All servers MUST, as minimum, support BF/128 encryption; admins
	MAY choose to use another cipher which is available at their
	disposal.

	If a cipher is not supported on BOTH servers, the receiving
	server (the server which was connected to) should send back an
	error response.  See Section 3.5 ("Error Responses") for more
	information on the process for doing this.

	Servers which support regeneration of session keys MAY also
	include the DK ('Dynamic Key') capability.

3.2 - Key Generation
--------------------

	To initiate an encrypted link to another server, each server
	is required to generate a 512-bit random key, of which a portion
	will be used to decrypt all data received by the server.  This key
	MUST be generated by a cryptographically strong PRNG.

	This key should be stored, then encrypted to the other server's
	public key, and base64 encoded.

3.3 - Link Establishment
------------------------

	Once the initiating server (server A) has connected to the
	remote server (server B), it SHOULD send the CAPAB command,
	listing its capabilities (including the new ENC capability).

	It MUST then send a CRYPTLINK SERV command using the following
	syntax:

		CRYPTLINK SERV <irc.server.name> <key> :server info

	"<irc.server.name>" should be self-explanitory.  "<key>" is the
	base64-encoded key.  "server info" is the server's M-line.

	Servers MUST NOT send a PASS or initial SERVER command over an
	encrypted link.  However, SERVER commands are still used to
	introduce remote servers.  All encrypted links MUST support the
	TS protocol (as normally indicated by PASS ... :TS).

	On receiving the CAPAB command, server B MUST send its own
	CAPAB/CRYPTLINK SERV commands, and then decrypt the key.

	Server B should then use the cipher chosen by the remote end (to
	encrypt outgoing data), and extract the required number of bytes
	from the data received from server A.  It must then (using RSA)
	encrypt the session key to Server A's public key and base64
	encode it.

	It should then send a CRYPTLINK AUTH command as follows:

		CRYPTLINK AUTH <cipher> <base64-encoded session key>

	Once this command has been sent, the link MUST switch to being
	encrypted.  All future data sent over the link will be encrypted
	using the selected symmetric encryption cipher, with the key
	received from the remote server, using only the first N bits,
	where N is the key length of the negotiated cipher.  At this point,
	Server B SHOULD send an SVINFO command, followed by a normal
	net-burst.

	If the CAPAB lines exchanged indicated that both servers support
	ZIPLINKS for this link, the data will be "zipped" immediately
	before encrypting it.  The data will start to be "zipped" after
	the CRYPTLINK AUTH command is sent (i.e., at the same time as
	encryption).

	After receiving a CRYPTLINK AUTH command Server A MUST decrypt the
	session key returned by Server B and ensure it is correct.  If
	it is not, the server SHOULD notify online admins/IRCOps, and
	MUST drop the link.

	Server A will then send its own CRYPTLINK AUTH command, and switch
	to an encrypted link as above.  It SHOULD then send an SVINFO
	command, and a normal net-burst.

	Server B MUST also validate the CRYPTLINK AUTH response as above.

3.4 - Key Regeneration
----------------------

	The servers MAY regenerate the session key they use to encrypt
	outgoing data at any point during a link, if the link supports the
	DK ("Dynamic Key") capability.

	They should generate a new key, encode it to the remote server's
	PUBLIC key as in the initial key exchange, then send a CRYPTKEY
	command as follows:

		:<servername> CRYPTKEY <key>

	This command should (obviously) be encrypted by the original key,
	and lines from then on should be encrypted with the new key.

	As of present, hybrid-6 does not support key regeneration.

3.5 - Error Responses
---------------------

	There are many possibilities of failure/error during the
	negotiation process.  Due to the vast diversity of these
	errors, a generic error response mechanism should be implemented.

	The stock ERROR command is used to spit out errors regarding
	all sorts of errors.  Example:

	Example:

		ERROR :BF/256 cipher not supported here.  Bugger off!

	This response MUST be sent immediately after any error is
	encountered.  For example, if the cipher negotiation phase
	fails, the receiving server MUST send an ERROR response once this
	is detected, and the socket MUST be closed.

	The output to the ERROR command can be anything.  Do not assume
	all ERROR messages for CRYPTLINK failures will be the same; they
	MAY be changed by administrators.

	See Section 4.0 ("Communication Phase Examples") for some more
	examples.

3.6 - The Validation Mechanism
------------------------------

	It is important to understand how the validation process
	works.  Section 3.2 ("Key Generation") briefly touches on
	this subject.

	Both servers have a pair of keys on their filesystem: a PUBLIC
	key, and a PRIVATE key.

	Each server should have a copy of the others' PUBLIC key.

	Herein we will refer to each server individually as "Server 1" and
	"Server 2."  In this example, Server 1 is connecting to Server 2.

	Server 1 connects to Server 2, and sends CAPAB.

	Server 1 then generates a unique 512-bit keyphrase.  This keyphrase
	is generated from a 64 bytes of random data taken from what is
	referred to as a PRNG ("Pseudo-Random Number Generator").  A PRNG
	could be something like /dev/urandom or something like the EGD
	("Entropy Gathering Daemon").

	The keyphrase is encrypted using Server 2's PUBLIC key.

	This keyphrase is sent to Server 2 during the CRYPTLINK SERV
	phase.

	Server 2 takes the keyphrase, and decrypts it using it's own
	PRIVATE key.  If the decryption fails, an ERROR is sent, and the
	connection is dropped.

	Server 2 sends the decrypted data (except that it is base64
	encoded) back to Server 1 during the CRYPTLINK AUTH phase.

	Server 1 decodes the base64 encoding, and compares the data
	to that of the data which was originally sent during the
	CRYPTLINK SERV phase.

	If the data matches, the authentication is legitimate, and
	the servers officially link up.

	If the data does NOT match, then someone is being naughty.
	In this case, an ERROR is sent, and the connection is dropped.


4.0 - Communication Phase Examples
----------------------------------

  Server #1 connects to Server #2
  ===============================
     1.  Server #1 initiates connection to Server #2 on port 6667.
     2.  Server #2 answers on port 6667.
     3.  Server #1 sends:

           CAPAB :QS EX CHW IE EOB KLN GLN HOPS AOPS UID ZIP ENC:BF/256

     4.  Server #2 checks to see if it supports BF/256.  It does.
     5.  Server #1 sends the following:

           CRYPTLINK SERV irc.server1 <keyphase> :We like IRC! Woohoo!

     7.  Server #2 sends:

           CAPAB :QS EX CHW IE EOB KLN GLN HOPS HUB AOPS UID ZIP ENC:BF/256

     8.  Server #1 acknowledges the CAPAB internally.
     9.  Server #2 sends:

           CRYPTLINK SERV irc.server2 <key> :Our server is better than yours!

    10.  Server #2 sends:

           CRYPTLINK AUTH BF/256 <base64-encoded session key>

    11.  Server #1 decrypts the key, and validates it.  It's correct.
    12.  All transmissions from here on are encrypted.


  Server #1 connects to server #2, cipher fails
  =============================================
     1.  Same as Steps 1-3 of the above example.
     4.  Server #2 checks to see if it supports BF/256.  It does NOT.
     5.  Server #2 sends:

           ERROR :CRYPTLINK - BF/256 cipher not supported here.  Bugger off!

     6.  Server #1 is aware of the error, logs it, and/or informs
         administrators/opers on the server of the cipher failure.
     7.  Server #2 closes the socket.


  Server #1 connects to server #2, CRYPTAUTH fails
  ================================================
     1.  Same as Steps 1-10 of the above example.
    11.  Server #1 decrypts the key, and validates it.  It's INCORRECT.
    12.  Server #1 sends:

           ERROR :CRYPTLINK - Key invalid.  Home, James.

    13.  Server #1 is aware of the error, logs it, and/or informs
         administrators/opers on the server of the key mismatch.
    14.  Server #1 closes the socket.



Last modified:	2001-07-02
